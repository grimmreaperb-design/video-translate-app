<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§ª Teste WebRTC Minimalista</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .video-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 300px;
            height: 200px;
            background: #000;
            border-radius: 8px;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .logs {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .status.connecting { background: #fff3cd; color: #856404; }
        .status.connected { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§ª Teste WebRTC Minimalista</h1>
        <p>Este teste isolado verifica se o WebRTC funciona com o backend Socket.IO sem React.</p>
        
        <div class="status" id="status">ğŸ”„ Aguardando...</div>
        
        <div class="controls">
            <button id="startBtn" onclick="startTest()">ğŸš€ Iniciar Teste</button>
            <button id="connectBtn" onclick="connectSocket()" disabled>ğŸ”Œ Conectar Socket</button>
            <button id="joinBtn" onclick="joinRoom()" disabled>ğŸ  Entrar na Sala</button>
            <button id="clearBtn" onclick="clearLogs()">ğŸ§¹ Limpar Logs</button>
        </div>
        
        <div class="video-container">
            <div>
                <h3>ğŸ“¹ VÃ­deo Local</h3>
                <video id="localVideo" autoplay muted></video>
            </div>
            <div>
                <h3>ğŸ“º VÃ­deo Remoto</h3>
                <video id="remoteVideo" autoplay></video>
            </div>
        </div>
        
        <div>
            <h3>ğŸ“‹ Logs de DiagnÃ³stico</h3>
            <div class="logs" id="logs"></div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // ğŸ” DIAGNÃ“STICO PROFUNDO: Capturar erros silenciosos globalmente
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            log('[UNCAUGHT] âŒ window.onerror: ' + msg + ' at ' + url + ':' + lineNo + ':' + columnNo, 'error');
        };

        window.onunhandledrejection = function (event) {
            log('[UNCAUGHT] âŒ Promise rejection: ' + event.reason, 'error');
        };

        // VariÃ¡veis globais
        let socket = null;
        let localStream = null;
        let peerConnection = null;
        let isInitiator = false;
        const roomId = 'test-room-' + Date.now();
        const userId = 'test-user-' + Date.now();

        // ConfiguraÃ§Ã£o ICE
        const iceServers = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ];

        // FunÃ§Ã£o de log
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('logs');
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : 'â„¹ï¸';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = 'status ' + type;
        }

        function clearLogs() {
            document.getElementById('logs').textContent = '';
        }

        // ğŸ”§ 5. Verificar permissÃµes de cÃ¢mera/microfone explicitamente
        async function startTest() {
            try {
                log('[PERMISSION] ğŸ” Verificando permissÃµes de mÃ­dia...');
                updateStatus('ğŸ”„ Obtendo acesso Ã  cÃ¢mera e microfone...', 'connecting');
                
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 },
                    audio: true
                });
                
                log('[PERMISSION] âœ… Acesso Ã  mÃ­dia concedido: ' + localStream.getTracks().map(t => t.kind).join(', '), 'success');
                
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('connectBtn').disabled = false;
                
                updateStatus('âœ… MÃ­dia local obtida com sucesso', 'connected');
                
            } catch (error) {
                log('[PERMISSION] âŒ Erro ao acessar mÃ­dia: ' + error.message, 'error');
                updateStatus('âŒ Erro ao acessar cÃ¢mera/microfone', 'error');
            }
        }

        function connectSocket() {
            try {
                log('ğŸ”Œ Conectando ao Socket.IO...');
                updateStatus('ğŸ”„ Conectando ao servidor...', 'connecting');
                
                // Usar a mesma URL do backend em produÃ§Ã£o
                socket = io('https://video-translate-app.onrender.com', {
                    transports: ['websocket', 'polling'],
                    timeout: 15000,
                    forceNew: true,
                    reconnection: false
                });

                socket.on('connect', () => {
                    log('âœ… Socket conectado com sucesso! ID: ' + socket.id, 'success');
                    updateStatus('âœ… Conectado ao servidor', 'connected');
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('joinBtn').disabled = false;
                });

                socket.on('disconnect', (reason) => {
                    log('âŒ Socket desconectado: ' + reason, 'error');
                    updateStatus('âŒ Desconectado do servidor', 'error');
                });

                socket.on('connect_error', (error) => {
                    log('âŒ Erro de conexÃ£o: ' + error.message, 'error');
                    updateStatus('âŒ Erro de conexÃ£o', 'error');
                });

                // Eventos WebRTC
                socket.on('webrtc-offer', handleOffer);
                socket.on('webrtc-answer', handleAnswer);
                socket.on('webrtc-ice-candidate', handleIceCandidate);
                socket.on('user-joined', handleUserJoined);

            } catch (error) {
                log('âŒ Erro ao conectar socket: ' + error.message, 'error');
                updateStatus('âŒ Erro de conexÃ£o', 'error');
            }
        }

        function joinRoom() {
            try {
                log('ğŸ  Entrando na sala: ' + roomId);
                updateStatus('ğŸ”„ Entrando na sala...', 'connecting');
                
                socket.emit('join-room', {
                    roomId: roomId,
                    user: {
                        id: userId,
                        name: 'Test User'
                    }
                });
                
                log('âœ… SolicitaÃ§Ã£o de entrada na sala enviada', 'success');
                updateStatus('âœ… Na sala de teste', 'connected');
                
            } catch (error) {
                log('âŒ Erro ao entrar na sala: ' + error.message, 'error');
                updateStatus('âŒ Erro ao entrar na sala', 'error');
            }
        }

        function createPeerConnection() {
            try {
                log('ğŸ”— Criando peer connection...');
                
                peerConnection = new RTCPeerConnection({ iceServers });

                // Adicionar tracks locais
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                        log('âœ… Track adicionado: ' + track.kind, 'success');
                    });
                }

                // ğŸ”§ 3. Verificar o pc.oniceconnectionstatechange para detectar falhas
                peerConnection.oniceconnectionstatechange = () => {
                    log('[ICE] Estado ICE: ' + peerConnection.iceConnectionState);
                    if (peerConnection.iceConnectionState === 'failed') {
                        log('[ICE] âŒ ConexÃ£o ICE falhou', 'error');
                    }
                };

                peerConnection.onconnectionstatechange = () => {
                    log('[PEER] Estado da conexÃ£o: ' + peerConnection.connectionState);
                };

                peerConnection.onicecandidate = (event) => {
                    if (event.candidate && socket) {
                        log('ğŸ§Š Enviando ICE candidate...');
                        socket.emit('webrtc-ice-candidate', {
                            to: 'remote-user',
                            candidate: event.candidate
                        });
                    }
                };

                peerConnection.ontrack = (event) => {
                    log('ğŸ“¹ Stream remoto recebido!', 'success');
                    const remoteVideo = document.getElementById('remoteVideo');
                    remoteVideo.srcObject = event.streams[0];
                    
                    // ğŸ”§ 4. Adicionar fallback de reconexÃ£o se ontrack nÃ£o disparar
                    setTimeout(() => {
                        if (!remoteVideo.srcObject) {
                            log('[TIMEOUT] ğŸ”„ Nenhuma stream recebida apÃ³s 5s', 'error');
                        }
                    }, 5000);
                };

                return peerConnection;

            } catch (error) {
                log('âŒ Erro ao criar peer connection: ' + error.message, 'error');
                return null;
            }
        }

        async function handleUserJoined(user) {
            try {
                log('ğŸ‘¤ UsuÃ¡rio entrou: ' + user.name + ' (' + user.id + ')');
                
                if (user.id === userId) {
                    log('âš ï¸ Ignorando prÃ³prio usuÃ¡rio');
                    return;
                }

                // ğŸ”§ 1. Verifique se hÃ¡ erro de execuÃ§Ã£o ao adicionar o novo usuÃ¡rio
                try {
                    isInitiator = true;
                    const pc = createPeerConnection();
                    if (!pc) {
                        log('âŒ Falha ao criar peer connection', 'error');
                        return;
                    }

                    log('ğŸ“ Criando offer...');
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    socket.emit('webrtc-offer', {
                        to: user.id,
                        offer: offer
                    });
                    
                    log('âœ… Offer enviado para ' + user.name, 'success');
                    
                } catch (error) {
                    log('[FATAL] âŒ Erro ao criar offer para novo usuÃ¡rio: ' + error.message, 'error');
                }

            } catch (error) {
                log('[FATAL] âŒ Erro no handler user-joined: ' + error.message, 'error');
            }
        }

        async function handleOffer(data) {
            try {
                log('ğŸ“¨ Offer recebido de: ' + data.from);
                
                if (!peerConnection) {
                    peerConnection = createPeerConnection();
                }
                
                await peerConnection.setRemoteDescription(data.offer);
                log('ğŸ“Œ Remote description definida');
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                socket.emit('webrtc-answer', {
                    to: data.from,
                    answer: answer
                });
                
                log('âœ… Answer enviado', 'success');
                
            } catch (error) {
                log('âŒ Erro ao processar offer: ' + error.message, 'error');
            }
        }

        async function handleAnswer(data) {
            try {
                log('ğŸ“¨ Answer recebido de: ' + data.from);
                
                if (peerConnection) {
                    await peerConnection.setRemoteDescription(data.answer);
                    log('âœ… Answer processado', 'success');
                } else {
                    log('âŒ Nenhuma peer connection encontrada para answer', 'error');
                }
                
            } catch (error) {
                log('âŒ Erro ao processar answer: ' + error.message, 'error');
            }
        }

        async function handleIceCandidate(data) {
            try {
                log('ğŸ§Š ICE candidate recebido de: ' + data.from);
                
                if (peerConnection) {
                    await peerConnection.addIceCandidate(data.candidate);
                    log('âœ… ICE candidate adicionado', 'success');
                } else {
                    log('âŒ Nenhuma peer connection encontrada para ICE candidate', 'error');
                }
                
            } catch (error) {
                log('âŒ Erro ao processar ICE candidate: ' + error.message, 'error');
            }
        }

        // Inicializar logs
        log('ğŸ§ª Teste WebRTC Minimalista iniciado');
        log('ğŸ“‹ InstruÃ§Ãµes:');
        log('1. Clique em "Iniciar Teste" para obter acesso Ã  cÃ¢mera');
        log('2. Clique em "Conectar Socket" para conectar ao servidor');
        log('3. Clique em "Entrar na Sala" para entrar na sala de teste');
        log('4. Abra esta pÃ¡gina em outra aba/janela para testar P2P');
        log('');
        log('ğŸ” Room ID: ' + roomId);
        log('ğŸ†” User ID: ' + userId);
    </script>
</body>
</html>