<!DOCTYPE html>
<html>
<head>
    <title>Teste WebRTC - Mock (Sem C√¢mera)</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .log { margin: 5px 0; padding: 5px; border-left: 3px solid #ccc; }
        .success { border-color: #4CAF50; background: #f1f8e9; }
        .error { border-color: #f44336; background: #ffebee; }
        .info { border-color: #2196F3; background: #e3f2fd; }
        .warning { border-color: #ff9800; background: #fff3e0; }
        #logs { max-height: 500px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; }
    </style>
</head>
<body>
    <h1>üß™ Teste WebRTC - Simula√ß√£o Completa (Sem C√¢mera)</h1>
    <p>Este teste simula dois usu√°rios (Alice e Bob) fazendo uma negocia√ß√£o WebRTC completa sem usar c√¢meras reais.</p>
    
    <button onclick="startTest()">üöÄ Iniciar Teste</button>
    <button onclick="clearLogs()">üßπ Limpar Logs</button>
    
    <div id="logs"></div>
    
    <script>
        let testRunning = false;
        
        function log(message, type = 'info') {
            const logs = document.getElementById('logs');
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong>: ${message}`;
            logs.appendChild(div);
            logs.scrollTop = logs.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
        }

        // Mock MediaStream para simular v√≠deo sem usar c√¢mera real
        function createMockMediaStream() {
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');
            
            // Desenhar um padr√£o colorido
            ctx.fillStyle = '#' + Math.floor(Math.random()*16777215).toString(16);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.fillText('Mock Video', 250, 240);
            
            return canvas.captureStream(30);
        }

        async function startTest() {
            if (testRunning) {
                log('‚ö†Ô∏è Teste j√° est√° rodando!', 'warning');
                return;
            }
            
            // Verificar se Socket.IO carregou
            if (typeof io === 'undefined') {
                log('‚ùå Erro: Socket.IO n√£o carregou. Verifique sua conex√£o com a internet.', 'error');
                return;
            }
            
            testRunning = true;
            clearLogs();
            log('üöÄ Iniciando teste de negocia√ß√£o WebRTC...', 'info');
            log('‚úÖ Socket.IO carregado com sucesso', 'success');
            
            try {
                // Criar dois sockets - conectando diretamente ao backend
                const socketAlice = io('http://localhost:3001');
                const socketBob = io('http://localhost:3001');
                
                let alicePC = null;
                let bobPC = null;
                
                // Configura√ß√£o STUN/TURN
                const rtcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };

                // === ALICE ===
                socketAlice.on('connect', () => {
                    log('üü¢ Alice conectada ao servidor', 'success');
                    socketAlice.emit('join-room', {
                        roomId: 'test-room-mock',
                        user: { id: 'alice-mock-123', name: 'Alice (Mock)' }
                    });
                });

                socketAlice.on('user-joined', async (user) => {
                    if (user.id === 'bob-mock-456') {
                        log(`üî• Alice: Bob entrou na sala, criando oferta...`, 'info');
                        
                        // Criar PeerConnection para Alice
                        alicePC = new RTCPeerConnection(rtcConfig);
                        
                        // Adicionar mock stream
                        const mockStream = createMockMediaStream();
                        mockStream.getTracks().forEach(track => {
                            alicePC.addTrack(track, mockStream);
                        });
                        
                        // Configurar eventos
                        alicePC.onicecandidate = (event) => {
                            if (event.candidate) {
                                log('üßä Alice: Enviando ICE candidate', 'info');
                                socketAlice.emit('webrtc-ice-candidate', {
                                    to: 'bob-mock-456',
                                    candidate: event.candidate
                                });
                            }
                        };
                        
                        alicePC.onconnectionstatechange = () => {
                            log(`üîó Alice: Connection state = ${alicePC.connectionState}`, 'info');
                            if (alicePC.connectionState === 'connected') {
                                log('‚úÖ Alice: Conex√£o P2P estabelecida!', 'success');
                            }
                        };
                        
                        // Criar e enviar oferta
                        const offer = await alicePC.createOffer();
                        await alicePC.setLocalDescription(offer);
                        
                        socketAlice.emit('webrtc-offer', {
                            to: 'bob-mock-456',
                            offer: offer
                        });
                        log('üìû Alice: Oferta enviada para Bob', 'success');
                    }
                });

                socketAlice.on('webrtc-answer', async (data) => {
                    log('‚úÖ Alice: Resposta recebida de Bob', 'success');
                    if (alicePC) {
                        await alicePC.setRemoteDescription(data.answer);
                        log('üéØ Alice: Remote description definida', 'success');
                    }
                });

                socketAlice.on('webrtc-ice-candidate', async (data) => {
                    log('üßä Alice: ICE candidate recebido de Bob', 'info');
                    if (alicePC && data.candidate) {
                        await alicePC.addIceCandidate(data.candidate);
                    }
                });

                // === BOB ===
                socketBob.on('connect', () => {
                    log('üü¢ Bob conectado ao servidor', 'success');
                    // Bob entra 2 segundos depois
                    setTimeout(() => {
                        socketBob.emit('join-room', {
                            roomId: 'test-room-mock',
                            user: { id: 'bob-mock-456', name: 'Bob (Mock)' }
                        });
                        log('üè† Bob: Entrando na sala...', 'info');
                    }, 2000);
                });

                socketBob.on('webrtc-offer', async (data) => {
                    log('üìû Bob: Oferta recebida de Alice', 'success');
                    
                    // Criar PeerConnection para Bob
                    bobPC = new RTCPeerConnection(rtcConfig);
                    
                    // Adicionar mock stream
                    const mockStream = createMockMediaStream();
                    mockStream.getTracks().forEach(track => {
                        bobPC.addTrack(track, mockStream);
                    });
                    
                    // Configurar eventos
                    bobPC.onicecandidate = (event) => {
                        if (event.candidate) {
                            log('üßä Bob: Enviando ICE candidate', 'info');
                            socketBob.emit('webrtc-ice-candidate', {
                                to: 'alice-mock-123',
                                candidate: event.candidate
                            });
                        }
                    };
                    
                    bobPC.onconnectionstatechange = () => {
                        log(`üîó Bob: Connection state = ${bobPC.connectionState}`, 'info');
                        if (bobPC.connectionState === 'connected') {
                            log('‚úÖ Bob: Conex√£o P2P estabelecida!', 'success');
                            log('üéâ SUCESSO: Negocia√ß√£o WebRTC completa!', 'success');
                            testRunning = false;
                        }
                    };
                    
                    bobPC.ontrack = (event) => {
                        log('üì∫ Bob: Stream de v√≠deo recebido de Alice', 'success');
                    };
                    
                    // Processar oferta e criar resposta
                    await bobPC.setRemoteDescription(data.offer);
                    const answer = await bobPC.createAnswer();
                    await bobPC.setLocalDescription(answer);
                    
                    socketBob.emit('webrtc-answer', {
                        to: 'alice-mock-123',
                        answer: answer
                    });
                    log('‚úÖ Bob: Resposta enviada para Alice', 'success');
                });

                socketBob.on('webrtc-ice-candidate', async (data) => {
                    log('üßä Bob: ICE candidate recebido de Alice', 'info');
                    if (bobPC && data.candidate) {
                        await bobPC.addIceCandidate(data.candidate);
                    }
                });

                // Timeout de seguran√ßa
                setTimeout(() => {
                    if (testRunning) {
                        log('‚è∞ Timeout: Teste demorou mais que 30 segundos', 'error');
                        testRunning = false;
                    }
                }, 30000);

            } catch (error) {
                log(`‚ùå Erro durante o teste: ${error.message}`, 'error');
                testRunning = false;
            }
        }
    </script>
</body>
</html>